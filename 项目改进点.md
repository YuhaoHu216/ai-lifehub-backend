# 要补充的业务

## 1.做定时任务和延迟队列

### 定时任务
固定执行周期，明确时间点
- 每天凌晨的数据备份
- 每小时的系统监控检查
- 每月财务报表生成
### 延迟队列
触发时间不固定，延迟时长确定
- 订单支付超时自动取消
- 注册发邮件通知
- 优惠卷到期前提醒通知 
## 2.日志

## 3.统计QPS(?)
1. 测试时单机吞吐量受很多因素制约,还是要真实的生产环境中才有代表性
2. 

## 4.削峰与限流

## 5.文件的分块上传

## 6.后续支付成功(数据插入成功)通知
1. 使用canal解耦,一插入数据就监听到binlog,然后发哦是那个mq异步通知,对原有业务代码0侵入

## 7.项目使用一些设计模式

## 8.用AOP实现一些操作

## 9.给项目整一个几百万数据的表,进行SQL优化

## 10.mybatis的插件进行功能加强

# 已有的业务说明
## 1. 超卖及其解决方法
因为每个线程是先查询再扣减库存,所以就会存在一个线程先查,但是还没扣减时其他线程进来查询就会造成超卖问题.
解决方案:加锁
- 悲观锁:认为每次操作都会有线程安全问题,所以每次操作数据之前都获取锁,来确保线程串行执行.有严重性能问题
- 乐观锁:认为线程安全一定不会发生,只是在更改数据之前去判断数据有没有被其他线程修改
## 2. 一人一单及其实现
在多线程并发的场景下就会出现和超卖一样的问题,虽然之前用乐观锁解决了.但是乐观锁常用于更新数据上,而在插入数据时就要用悲观锁了.
可以把整个方法都加上锁,但是这样锁的粒度就太大了会发生
- 并发度下降,进入方法都要先等待,不能先执行与核心无关的代码
- 锁竞争严重,锁覆盖的范围太大,线程争抢同一把锁的机会更多,锁竞争变得激烈，线程频繁地进入阻塞和唤醒状态。CPU 空转、上下文切换频繁，性能开销显著。
- 响应时间增加,等待锁的时间变长,用户体验差
- 扩展性变差,当线程数或CPU核数增加时性能提升有限
实现时的问题及解决
1. 锁名用的是userId,如果我们直接使用userId.toString()拿到的其实是不同的对象,会导致锁不住
- 解决:使用intern()方法,userId.toString().intern(),从常量池中拿到
2. 因为对当前方法使用@Transactional注解,被事务所控制,如果在方法内部加锁就会导致事务还没提交时锁已经释放(锁与事务边界不一致),因为@Transactional 方法内部的代码执行完 并不代表事务提交了,也会导致问题
- 解决:在外部给方法的调用加锁
```java
Long userId = UserHolder.getUser().getId();
synchronized (userId.toString().intern()){
    return this.createVoucherOrder(voucherId);
}
```
3. 修改后因为使用this调用,事务想生效还得要使用代理
   Spring 的事务（@Transactional）、日志、缓存、权限等功能，通常是通过 动态代理（AOP Proxy） 来实现的。
当你在一个 Spring Bean 中调用自身的方法时：
```java
this.createVoucherOrder(voucherId);
```
这里的 this 指向的是 当前类的原始对象，而不是 Spring 创建的代理对象。
因此，这个调用不会经过 AOP 代理，也就不会触发诸如：
- 事务管理（@Transactional）
- 异常回滚
- 日志切面
- 其他 AOP 增强逻辑

- 解决:
```java
synchronized (userId.toString().intern()){
    // 获取代理对象
    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
    return proxy.createVoucherOrder(voucherId);
}
```
导入依赖

```xml
 <dependency>
       <groupId>org.aspectj</groupId>
       <artifactId>aspectjweaver</artifactId>
</dependency>
```
为启动类添加注解(来暴露代理对象)

```java
@EnableAspectJAutoProxy(exposeProxy  = true)
```
将seckillVoucher方法上的@Transactional注解去掉

## 3.分布式锁

使用Redis实现分布式锁,集群下单个服务的锁就没有用了.

问题:

- 误删情况(在存锁时存入线程标识,删锁时判断)
- 删锁时的原子性问题

线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了(比如要释放锁前阻塞,如垃圾回收,结果超时释放了锁)， 那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，

- 解决:使用lua脚本让拿锁，比锁，删锁有原子性

## 4.Redisson

为了解决基于set nx分布式锁的问题

### 1.不可重入性（Reentrancy）

- 问题：同一个线程/实例如果多次加锁（同一资源），第二次会失败。
- 原因：Redis 只看到锁是否存在，不区分锁的“持有者”。
- 结果：不能支持像 Java `ReentrantLock` 那样的可重入特性。

Redisson 解决方式：

- Redisson 为每个线程维护一个 “锁标识” 和 “重入计数”，在同一线程多次加锁时只增加计数，不会重复创建锁。

------

### 2.锁误释放问题（安全性）

- 问题：如果锁过期时间到了，但任务还没执行完，锁自动释放；
  - 此时另一个客户端可能获得锁；
  - 旧客户端任务完成后执行 `DEL` 删除锁；
  - 导致删除了别人新加的锁。

Redisson 解决方式：

- 使用 **锁续期（Watchdog）机制**：
  - 加锁成功后会自动启动一个后台线程；
  - 每隔一定时间（默认 10s）自动延长锁的过期时间；
  - 直到任务完成或手动解锁；
  - 避免锁被意外释放。

------

### 3.无法应对 Redis 宕机或主从切换（高可用问题）

- 问题：
  - 如果使用单节点 Redis，Redis 宕机后锁信息丢失；
  - 如果使用主从模式，主节点刚写入锁还未同步到从节点就宕机；
  - 从节点晋升为主后，锁丢失，其他客户端可能再次获得锁；
  - 出现 **多个客户端同时持有锁** 的情况（锁失效）。

Redisson 解决方式：

- 实现 **RedLock 算法**（Redis 作者 Antirez 提出的分布式锁算法）：
  - 同时在多个 Redis 实例上加锁；
  - 超过半数（N/2 + 1）成功才算获取锁；
  - 确保单点故障不会导致锁失效；
  - 提高系统容错性。

------

### 4.无锁超时续期机制（任务执行时间不确定）

- 简单 SET NX 锁必须提前估计任务执行时长；
- 如果估计过短，任务还没执行完锁就过期；
- 估计过长，其他客户端要等很久才能获得锁；
- 缺乏动态续期导致性能和可靠性都不好。

Redisson：

- 有自动 **Watchdog** 机制（动态续期），不需要手动设定长 TTL。

------

### 5.无公平性 / 无阻塞队列

- 简单锁：多个客户端同时争抢锁，随机一个成功；
- 没有排队、优先级、等待机制；
- 可能导致“饥饿”问题（部分客户端长期抢不到锁）。

Redisson：

- 实现了公平锁（Fair Lock）；
- 有等待队列机制；
- 支持 tryLock（带超时时间）等高级特性。

------

### 6.Lua 脚本释放锁原子性问题

- 如果解锁逻辑是：

  ```
  if redis.get(key) == value:
      redis.del(key)
  ```

  在两步执行过程中 Redis 不是原子操作，可能出现 race condition。

- 需要使用 Lua 脚本保证原子性。

Redisson：

- 所有加锁、解锁、续期逻辑都在 Lua 脚本中执行；
- 保证原子性和一致性。



